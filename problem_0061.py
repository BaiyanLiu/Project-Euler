"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	P4,n=n^2 	  	1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

    1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (
    including the last number with the first).
    2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by
    a different number in the set.
    3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square,
pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

https://projecteuler.net/problem=61
"""


import utils


def main():
    tri_nums = utils.triangle_nums(45, 141)
    sqr_nums = utils.square_nums(32, 100)
    pen_nums = utils.pentagonal_nums(26, 82)
    hex_nums = utils.hexagonal_nums(23, 71)
    hep_nums = {i * (5 * i - 3) // 2 for i in range(21, 64)}
    oct_nums = {i * (3 * i - 2) for i in range(19, 59)}
    all_seqs = [tri_nums, sqr_nums, pen_nums, hex_nums, hep_nums, oct_nums]
    print(next(group_sum for i in tri_nums if (group_sum := find_group_sum({0}, [i], all_seqs))))


def find_group_sum(seqs: set[int], nums: list[int], all_seqs: list[set[int]]) -> int:
    curr_num = nums[-1]
    curr_suffix = curr_num % 100
    if len(nums) == 6:
        return sum(nums) if nums[0] // 100 == curr_suffix else None
    for seq in [i for i in range(len(all_seqs)) if i not in seqs]:
        for num in [i for i in all_seqs[seq] if i // 100 == curr_suffix]:
            if group_sum := find_group_sum(seqs | {seq}, nums + [num], all_seqs):
                return group_sum


if __name__ == '__main__':
    main()
